package org.entirej;import java.sql.Array;import java.sql.CallableStatement;import java.sql.Connection;import java.sql.ResultSet;import java.sql.SQLData;import java.sql.SQLException;import java.sql.Struct;import java.sql.Types;import java.util.ArrayList;import java.util.List;import oracle.sql.ARRAY;import oracle.sql.ArrayDescriptor;import org.entirej.framework.core.EJApplicationException;import org.entirej.framework.core.EJForm;import org.entirej.framework.core.EJMessage;import org.entirej.framework.core.interfaces.EJFrameworkConnection;import org.entirej.framework.core.service.EJStatementExecutor;import org.entirej.framework.core.service.EJStatementParameter;import org.slf4j.Logger;import org.slf4j.LoggerFactory;public class OracleStatementExecutor extends EJStatementExecutor{    private static Logger                logger                  = LoggerFactory.getLogger(OracleStatementExecutor.class);    static final ThreadLocal<Connection> CONNECTION_THREAD_LOCAL = new ThreadLocal<Connection>();    public int executePLSQLStoredProcedure(EJForm form, String procedureStatement, EJStatementParameter... parameters)    {        if (form == null)        {            throw new NullPointerException("Form passed to executeStoredProcedure cannot be null");        }        return executePLSQLStoredProcedure(form.getConnection(), procedureStatement, parameters);    }    public int executePLSQLStoredProcedure(EJFrameworkConnection fwkConnection, String procedureStatement, EJStatementParameter... parameters)    {        logger.trace("START executePLSQLStoredProcedure");        if (fwkConnection == null)        {            throw new NullPointerException("No EJFrameworkConnection passed to OracleStatementExecutor.executeStoredProcedure");        }        CallableStatement proc = null;        try        {            Object obj = fwkConnection.getConnectionObject();            if (fwkConnection.getConnectionObject() == null || !(fwkConnection.getConnectionObject() instanceof Connection))            {                throw new EJApplicationException(new EJMessage(                        "The StatementExecutor requires the ConnectionFactory to return a JDBC Connection but another type was returned"));            }            logger.trace("     Getting connection");            Connection connection = (Connection) fwkConnection.getConnectionObject();            logger.trace("     Got connection");            CONNECTION_THREAD_LOCAL.set(connection);            logger.trace("     Preparing Call");            proc = connection.prepareCall(procedureStatement);            logger.trace("     Call Prepared");            int pos = 0;            logger.trace("     Setting Parameters");            for (EJStatementParameter parameter : parameters)            {                pos++;                switch (parameter.getParameterType())                {                    case IN:                        if (parameter.getValue() == null)                        {                            proc.setNull(pos, parameter.getJdbcType());                        }                        else                        {                            proc.setObject(pos, parameter.getValue());                        }                        break;                    case INOUT:                        parameter.setPosition(pos);                        if (parameter instanceof EJStatementParameterArray)                        {                            proc.setArray(pos, createArray((EJStatementParameterArray<?>) parameter));                        }                        else                        {                            if (parameter.getValue() == null)                            {                                proc.setNull(pos, parameter.getJdbcType());                            }                            else                            {                                proc.setObject(pos, parameter.getValue());                            }                        }                        if (parameter.getJdbcType() == Types.ARRAY)                        {                            proc.registerOutParameter(pos, Types.ARRAY, ((EJStatementParameterArray<?>) parameter).getArrayTypeName());                        }                        else if (parameter.getJdbcType() == Types.STRUCT)                        {                            proc.registerOutParameter(pos, Types.STRUCT, ((EJStatementParameterStruct<?>) parameter).getStructTypeName());                        }                        else                        {                            proc.registerOutParameter(pos, parameter.getJdbcType());                        }                        break;                    case OUT:                    case RETURN:                        if (parameter.getJdbcType() == Types.ARRAY)                        {                            createArray((EJStatementParameterArray<?>) parameter);                            proc.registerOutParameter(pos, Types.ARRAY, ((EJStatementParameterArray<?>) parameter).getArrayTypeName());                        }                        else if (parameter.getJdbcType() == Types.STRUCT)                        {                            proc.registerOutParameter(pos, Types.STRUCT, ((EJStatementParameterStruct<?>) parameter).getStructTypeName());                        }                        else                        {                            proc.registerOutParameter(pos, parameter.getJdbcType());                        }                        parameter.setPosition(pos);                        break;                }            }            logger.trace("     Parameters Set");            logger.trace("     Executing ");            proc.execute();            logger.trace("     Executing Completed");            logger.trace("     Extracting Values");            for (EJStatementParameter parameter : parameters)            {                switch (parameter.getParameterType())                {                    case INOUT:                    case OUT:                    case RETURN:                        extractValue(proc, parameter.getPosition(), parameter);                        break;                    case IN:                        break;                }            }            logger.trace("     Values Extracted");        }        catch (Exception e)        {            try            {                                proc.close();                fwkConnection.rollback();            }            catch (SQLException e2)            {            }            throw new EJApplicationException(e.getMessage(), e);        }        finally        {            try            {                proc.close();                fwkConnection.close();            }            catch (SQLException e)            {            }        }        logger.trace("END executePLSQLStoredProcedure");        return 0;    }    private void extractValue(CallableStatement cstmt, int pos, EJStatementParameter parameter) throws SQLException, InstantiationException,            IllegalAccessException    {        if (parameter instanceof EJStatementParameterArray)        {            Array arrayValue = cstmt.getArray(pos);            extractArrayValue(arrayValue, (EJStatementParameterArray<?>) parameter);        }        else if (parameter instanceof EJStatementParameterStruct)        {            Struct structValue = (Struct) cstmt.getObject(pos);            extractStructValue(structValue, (EJStatementParameterStruct<?>) parameter);        }        else        {            parameter.setValue(cstmt.getObject(pos));        }    }    @SuppressWarnings("unchecked")    public synchronized static <E> void extractArrayValue(Array arrayValue, EJStatementParameterArray<?> parameter)    {        logger.trace("START  extractArrayValue");        try        {            logger.trace("START  Creating value Array");            List<E> valueArray = new ArrayList<E>();            logger.trace("START  creating Datum Array");            Object[] datumArray = (arrayValue != null) ? (Object[]) arrayValue.getArray() : null;            logger.trace("DONE  Datum Array Created");            logger.trace("START  extracting resultset");            /*             * logger.trace("START  extracting resultset"); if (arrayValue !=             * null) { ResultSet rset = arrayValue.getResultSet(); while             * (rset.next()) { Object obj = rset.getObject(2); if (obj != null)             * { logger.trace("          -> Getting Struct"); Struct str =             * (Struct) obj; logger.trace("          -> Got Struct");             * logger.trace("          -> Creating SQLData"); SQLData data =             * (SQLData) parameter.getClassInstance().newInstance();             * logger.trace("          -> SQLData Created");             * logger.trace("          -> Creating EJSQLInput"); EJSQLInput inp             * = new EJSQLInput(str);             * logger.trace("          -> Created EJSQLInput");             *              * logger.trace("          -> Reading.... {}",             * parameter.getArrayTypeName()); data.readSQL(inp,             * data.getSQLTypeName()); logger.trace("          -> All read");             * logger.trace("          -> adding to array"); valueArray.add((E)             * data); } else { valueArray.add(null); } } }             * logger.trace("DONE   extracting resultset");             */            if (datumArray != null)            {                for (Object element : datumArray)                {                    if (element != null)                    {                        logger.trace("          -> getting new ClassInstance {} ", parameter.getFieldName());                        SQLData data = (SQLData) parameter.getClassInstance().newInstance();                        logger.trace("          -> reading SQL ");                        data.readSQL(new EJSQLInput((Struct) element), data.getSQLTypeName());                        logger.trace("          -> adding to array");                        valueArray.add((E) data);                    }                    else                    {                        valueArray.add(null);                    }                }            }            logger.trace("END  extracting resultset");                        parameter.setValue(valueArray);            logger.trace("END   extractArrayValue");        }        catch (InstantiationException e)        {            throw new RuntimeException(e);        }        catch (IllegalAccessException e)        {            throw new RuntimeException(e);        }        catch (SQLException e)        {            throw new RuntimeException(e);        }    }    @SuppressWarnings("unchecked")    public synchronized static <E> void extractStructValue(Struct structValue, EJStatementParameterStruct<?> parameter)    {        try        {            if (structValue != null)            {                SQLData data = (SQLData) parameter.getClassInstance().newInstance();                data.readSQL(new EJSQLInput(structValue), data.getSQLTypeName());                parameter.setValue((E) data);            }            else            {                parameter.setValue(null);            }        }        catch (InstantiationException e)        {            throw new RuntimeException(e);        }        catch (IllegalAccessException e)        {            throw new RuntimeException(e);        }        catch (SQLException e)        {            throw new RuntimeException(e);        }    }    public static Array createArray(EJStatementParameterArray<?> parameter)    {        try        {            Connection connection = CONNECTION_THREAD_LOCAL.get();            if (connection == null)            {                throw new IllegalStateException();            }            ArrayDescriptor arraydescriptor = ArrayDescriptor.createDescriptor(((EJStatementParameterArray<?>) parameter).getArrayTypeName(), connection);            Array aArray = new ARRAY(arraydescriptor, arraydescriptor.getInternalConnection(), ((EJStatementParameterArray<?>) parameter).getArray());            return aArray;        }        catch (SQLException e)        {            e.printStackTrace();            throw new RuntimeException(e);        }    }}