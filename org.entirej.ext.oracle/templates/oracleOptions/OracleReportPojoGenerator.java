package org.entirej.generators;import java.math.BigDecimal;import java.sql.Date;import java.sql.Time;import java.sql.Timestamp;import java.sql.Types;import java.util.ArrayList;import java.util.HashSet;import java.util.LinkedHashMap;import java.util.Set;import org.entirej.framework.report.service.EJReportPojoContentGenerator;import org.entirej.framework.report.service.EJReportPojoGeneratorType;import org.entirej.framework.report.service.EJReportTableColumn;public class OracleReportPojoGenerator implements EJReportPojoContentGenerator{    private Set<String>                                _addedImports = new HashSet<String>();    private LinkedHashMap<String, EJReportTableColumn> _methodNames  = new LinkedHashMap<String, EJReportTableColumn>();    public String generateContent(EJReportPojoGeneratorType type)    {        StringBuilder fileBuilder = new StringBuilder();        fileBuilder.append("package ").append(type.getPackageName());        fileBuilder.append(";\n\n");        StringBuilder methodBuilder = new StringBuilder();        methodBuilder.append("\n");        StringBuilder paramaterBuilder = new StringBuilder();        ArrayList<String> propertyNames = new ArrayList<String>();        // add FieldName annotation to imports        fileBuilder.append("import ").append("org.entirej.framework.report.EJReportFieldName").append(";\n");        _addedImports.add("org.entirej.framework.core.EJReportFieldName");        // Oracle Type Imports        fileBuilder.append("import java.sql.*;\n");        fileBuilder.append("import java.util.ArrayList;\n");        _addedImports.add("java.sql.*");        _addedImports.add("java.util.ArrayList");        for (EJReportTableColumn param : type.getColumns())        {            if (param.getParameterType() != null)            {                continue;            }            String pack = null;            String typeName = null;            if (param.getDatatypeName().contains("."))            {                pack = param.getDatatypeName().substring(0, param.getDatatypeName().lastIndexOf("."));                typeName = param.getDatatypeName().substring(param.getDatatypeName().lastIndexOf(".") + 1);            }            else            {                typeName = param.getDatatypeName();            }            // If the type is not in java.lang, then add the import            // statement to the package Add the package name to a list, to            // ensure that the import is not duplicated            if (pack != null && (!"java.lang".equals(pack)) && (!_addedImports.contains(param.getDatatypeName())))            {                fileBuilder.append("import ").append(param.getDatatypeName()).append(";\n");                _addedImports.add(param.getDatatypeName());            }            String propertyName = "_" + databaseNameToObjectName(param.getName());            if (param.isArray())            {                paramaterBuilder.append("    private ArrayList<").append(typeName).append("> ").append(propertyName).append(";\n");            }            else            {                paramaterBuilder.append("    private ").append(typeName).append(" ").append(propertyName).append(";\n");            }            if (param.isArray())            {                if (!_addedImports.contains("org.entirej.EJStatementParameterArray"))                {                    fileBuilder.append("import org.entirej.EJStatementParameterArray;\n");                    fileBuilder.append("import org.entirej.framework.report.service.EJReportParameterType;\n");                    fileBuilder.append("import org.entirej.OracleReportStatementExecutor;\n");                    fileBuilder.append("import java.sql.Array;\n");                    _addedImports.add("org.entirej.EJStatementParameterArray");                }            }            methodBuilder.append(getMethods(typeName, param));            propertyNames.add(propertyName);        }        fileBuilder.append("\npublic class ").append(type.getClassName()).append(" implements SQLData\n{\n");        fileBuilder.append("    public static final String  _SQL_NAME     = \"").append(type.getProperty("OBJECT_NAME")).append("\";\n");        fileBuilder.append("    public static final int     _SQL_TYPECODE = Types.STRUCT;\n\n");        fileBuilder.append(paramaterBuilder.toString());        fileBuilder.append(methodBuilder.toString());        fileBuilder.append(getSQLDataMethods(type));        fileBuilder.append("\n}");        return fileBuilder.toString();    }    private String getSQLDataMethods(EJReportPojoGeneratorType type)    {        StringBuilder builder = new StringBuilder();        builder.append("    @Override\n");        builder.append("    public String getSQLTypeName() throws SQLException\n");        builder.append("    {\n");        builder.append("        return _SQL_NAME;\n");        builder.append("    }\n\n");        builder.append("    @Override\n");        builder.append("    public void readSQL(SQLInput stream, String typeName) throws SQLException\n");        builder.append("    {\n");        for (String name : _methodNames.keySet())        {            EJReportTableColumn col = _methodNames.get(name);            String typeName = col.getDatatypeName().substring(col.getDatatypeName().lastIndexOf(".") + 1);            if (col.isArray())            {                String paramName = name.toLowerCase();                builder.append("\n        EJStatementParameterArray<");                builder.append(typeName);                builder.append("> ").append(paramName).append(" = new EJStatementParameterArray<");                builder.append(typeName);                builder.append(">(").append(typeName).append(".class, EJReportParameterType.")                        .append(col.getParameterType() == null ? "INOUT" : col.getParameterType());                builder.append(", \"").append(type.getProperty("TABLE_NAME")).append("\"");                builder.append(");\n");                builder.append("        OracleReportStatementExecutor.extractArrayValue(stream.readArray(), ");                builder.append(paramName);                builder.append(");\n");                builder.append("        set").append(name).append("((ArrayList<");                builder.append(typeName);                builder.append(">) ").append(paramName).append(".getValue());\n");            }            else if (col.isStruct())            {                String paramName = name.toLowerCase();                                builder.append("\n        EJStatementParameterStruct<");                builder.append(typeName);                builder.append("> ").append(paramName).append(" = new EJStatementParameterStruct<");                builder.append(typeName);                builder.append(">(").append(typeName).append(".class, EJReportParameterType.").append(col.getParameterType() == null ? "INOUT" : col.getParameterType());                builder.append(",\"").append(typeName).append("\");");                builder.append("\n        OracleReportStatementExecutor.extractStructValue((Struct) stream.readObject(),").append(paramName).append(");");                builder.append("        set").append(name).append("((").append(typeName).append(") ").append(paramName).append(".getValue());\n");            }            else            {                builder.append("\n        set").append(name).append("(stream.read").append(typeName).append("());\n");            }        }        builder.append("    }\n\n");        builder.append("    @Override\n");        builder.append("    public void writeSQL(SQLOutput stream) throws SQLException\n");        builder.append("    {\n");        for (String name : _methodNames.keySet())        {            EJReportTableColumn col = _methodNames.get(name);            String typeName = col.getDatatypeName().substring(col.getDatatypeName().lastIndexOf(".") + 1);            if (col.isArray())            {                String paramName = name.toLowerCase();                builder.append("\n         ").append("if (get").append(name).append("() == null)");                builder.append("\n         {");                builder.append("\n             stream.writeArray(null);");                builder.append("\n         }");                builder.append("\n         else");                builder.append("\n         {");                builder.append("\n             ").append(typeName).append("[] ");                builder.append(paramName).append("Array = (");                builder.append(typeName).append("[]) get").append(name).append("().toArray(new ");                builder.append(typeName).append("[] {});");                builder.append("\n             EJStatementParameterArray<");                builder.append(typeName);                builder.append("> ").append(paramName).append(" = new EJStatementParameterArray<");                builder.append(typeName);                builder.append(">(").append(typeName).append(".class, EJReportParameterType.");                builder.append(col.getParameterType() == null ? "INOUT" : col.getParameterType());                builder.append(", ").append(paramName).append("Array, ").append("\"").append(type.getProperty("TABLE_NAME")).append("\");");                builder.append("\n             Array ").append(paramName).append("OraArray = OracleReportStatementExecutor.createArray(");                builder.append(paramName).append(");");                builder.append("\n             stream.writeArray(").append(paramName).append("OraArray);");                builder.append("\n         }");            }            else if (col.isStruct())            {                builder.append("\n         stream.writeObject(get").append(name).append("());\n");            }            else            {                builder.append("\n         stream.write").append(typeName).append("(get").append(name).append("());\n");            }        }        builder.append("    }\n\n");        return builder.toString();    }    private final String databaseNameToObjectName(String columnName)    {        if (columnName != null && !columnName.contains("_"))        {            if (columnName.toUpperCase().equals(columnName))            {                return columnName.toLowerCase();            }            return columnName;        }        int n = columnName.length();        StringBuilder fieldName = new StringBuilder(n);        for (int i = 0, flag = 0; i < n; i++)        {            char c = columnName.charAt(i);            if (c == '_')            {                flag = 1;                continue;            }            fieldName.append(flag == 0 ? Character.toLowerCase(c) : Character.toUpperCase(c));            flag = 0;        }        return fieldName.toString();    }    private String getMethods(String dataTypeName, EJReportTableColumn col)    {        String propertyName = databaseNameToObjectName(col.getName());        StringBuilder methodBuilder = new StringBuilder();        // Add the annotation        StringBuilder annotationString = new StringBuilder();        annotationString.append("    @EJReportFieldName(").append("\"").append(col.getName()).append("\")").append("\n");        methodBuilder.append(annotationString.toString());        String methodName = propertyName.substring(0, 1).toUpperCase();        methodName += propertyName.substring(1);        _methodNames.put(methodName, col);        System.out.println("colType: " + col.getDatatypeName());        // Add the getter method        if (col.isArray())        {            methodBuilder.append("    public ArrayList<").append(dataTypeName).append("> get");        }        else        {            methodBuilder.append("    public ").append(dataTypeName).append(" get");        }        methodBuilder.append(propertyName.substring(0, 1).toUpperCase());        methodBuilder.append(propertyName.substring(1)).append("()\n    {\n");        methodBuilder.append("        return _" + propertyName).append(";\n    }\n\n");        // Add the annotation        methodBuilder.append(annotationString.toString());        // Now add the setter method        methodBuilder.append("    public void set");        methodBuilder.append(propertyName.substring(0, 1).toUpperCase());        methodBuilder.append(propertyName.substring(1)).append("(");        System.out.println("");        if (col.isArray())        {            methodBuilder.append("ArrayList<").append(dataTypeName).append(">");        }        else        {            methodBuilder.append(dataTypeName);        }        methodBuilder.append(" ").append(propertyName).append(")\n");        methodBuilder.append("    {\n");        methodBuilder.append("        _").append(propertyName).append(" = ").append(propertyName);        methodBuilder.append(";\n    }\n\n");        return methodBuilder.toString();    }    public Class<?> getDataTypeForJdbcType(int jdbcType)    {        switch (jdbcType)        {            case Types.BOOLEAN:                return Boolean.class;            case Types.CHAR:            case Types.VARCHAR:            case Types.LONGVARCHAR:                return String.class;            case Types.FLOAT:            case Types.REAL:                return Float.class;            case Types.NUMERIC:            case Types.DECIMAL:            case Types.BIGINT:            case Types.DOUBLE:                return BigDecimal.class;            case Types.BIT:                return Boolean.class;            case Types.TINYINT:            case Types.SMALLINT:            case Types.INTEGER:                return Integer.class;            case Types.BINARY:            case Types.TIMESTAMP:                return Timestamp.class;            case Types.DATE:                return Date.class;            case Types.TIME:                return Time.class;            case Types.VARBINARY:            case Types.LONGVARBINARY:            default:                return String.class;        }    }}